// Code generated by 'duh generate duh --full' on {{.Timestamp}}. YOU CAN EDIT.

package {{.Package}}

import (
	"context"
	"log/slog"
{{if .IsFullTemplate}}	"sort"
	"sync"

	"github.com/duh-rpc/duh-go"
	pb "{{.ProtoImport}}"
	"github.com/google/uuid"
	"github.com/kapetan-io/tackle/set"
	"google.golang.org/protobuf/types/known/timestamppb"
{{else}}
	"github.com/duh-rpc/duh-go"
	pb "{{.ProtoImport}}"
{{end}})

type ServiceConfig struct {
	InstanceID string
	Log        *slog.Logger
}

{{if .IsFullTemplate}}type Service struct {
	users map[string]*pb.UserResponse
	mutex sync.RWMutex
	conf  ServiceConfig
}

func NewService(conf ServiceConfig) (ServiceInterface, error) {
	set.Default(&conf.Log, slog.Default())

	return &Service{
		users: make(map[string]*pb.UserResponse),
		conf:  conf,
	}, nil
}

func (s *Service) CreateUser(ctx context.Context, req *pb.CreateUserRequest, resp *pb.CreateUserResponse) error {
	if req.Email == "" {
		return duh.NewServiceError(duh.CodeBadRequest, "email is required", nil, nil)
	}
	if req.Name == "" {
		return duh.NewServiceError(duh.CodeBadRequest, "name is required", nil, nil)
	}

	s.mutex.Lock()
	defer s.mutex.Unlock()

	for _, user := range s.users {
		if user.Email == req.Email {
			return duh.NewServiceError(duh.CodeBadRequest, "user with this email already exists", nil, nil)
		}
	}

	now := timestamppb.Now()
	userID := uuid.New().String()

	user := &pb.UserResponse{
		CreatedAt: now,
		UserId:    userID,
		Email:     req.Email,
		Name:      req.Name,
		Age:       req.Age,
	}

	s.users[userID] = user

	resp.CreatedAt = now
	resp.UserId = userID
	resp.Email = req.Email
	resp.Name = req.Name

	return nil
}

func (s *Service) GetUserById(ctx context.Context, req *pb.GetUserRequest, resp *pb.UserResponse) error {
	if req.UserId == "" {
		return duh.NewServiceError(duh.CodeBadRequest, "user_id is required", nil, nil)
	}

	s.mutex.RLock()
	defer s.mutex.RUnlock()

	user, exists := s.users[req.UserId]
	if !exists {
		return duh.NewServiceError(duh.CodeNotFound, "user not found", nil, nil)
	}

	resp.CreatedAt = user.CreatedAt
	resp.UserId = user.UserId
	resp.Email = user.Email
	resp.Name = user.Name
	resp.Age = user.Age

	return nil
}

func (s *Service) ListUsers(ctx context.Context, req *pb.ListUsersRequest, resp *pb.ListUsersResponse) error {
	s.mutex.RLock()
	defer s.mutex.RUnlock()

	const defaultLimit = 10
	limit := defaultLimit
	if req.Limit > 0 {
		limit = int(req.Limit)
	}

	offset := 0
	if req.Offset > 0 {
		offset = int(req.Offset)
	}

	users := make([]*pb.UserResponse, 0, len(s.users))
	for _, user := range s.users {
		users = append(users, user)
	}

	switch req.SortBy {
	case pb.SortBy_SORT_BY_NAME:
		sort.Slice(users, func(i, j int) bool {
			return users[i].Name < users[j].Name
		})
	case pb.SortBy_SORT_BY_EMAIL:
		sort.Slice(users, func(i, j int) bool {
			return users[i].Email < users[j].Email
		})
	case pb.SortBy_SORT_BY_CREATED_AT:
		sort.Slice(users, func(i, j int) bool {
			return users[i].CreatedAt.AsTime().Before(users[j].CreatedAt.AsTime())
		})
	}

	total := len(users)

	if offset >= total {
		resp.Total = int32(total)
		resp.Users = []*pb.UserResponse{}
		resp.HasMore = false
		return nil
	}

	end := offset + limit
	if end > total {
		end = total
	}

	resp.Users = users[offset:end]
	resp.Total = int32(total)
	resp.HasMore = end < total

	return nil
}

func (s *Service) UpdateUser(ctx context.Context, req *pb.UpdateUserRequest, resp *pb.UpdateUserResponse) error {
	if req.UserId == "" {
		return duh.NewServiceError(duh.CodeBadRequest, "user_id is required", nil, nil)
	}

	s.mutex.Lock()
	defer s.mutex.Unlock()

	user, exists := s.users[req.UserId]
	if !exists {
		return duh.NewServiceError(duh.CodeNotFound, "user not found", nil, nil)
	}

	if req.Email != "" {
		for id, u := range s.users {
			if id != req.UserId && u.Email == req.Email {
				return duh.NewServiceError(duh.CodeBadRequest, "user with this email already exists", nil, nil)
			}
		}
		user.Email = req.Email
	}

	if req.Name != "" {
		user.Name = req.Name
	}

	if req.Age != 0 {
		user.Age = req.Age
	}

	now := timestamppb.Now()

	statusStr := req.Status.String()

	resp.UpdatedAt = now
	resp.CreatedAt = user.CreatedAt
	resp.UserId = user.UserId
	resp.Email = user.Email
	resp.Name = user.Name
	resp.Age = user.Age
	resp.Status = statusStr

	return nil
}

func (s *Service) Shutdown(ctx context.Context) error {
	s.mutex.Lock()
	defer s.mutex.Unlock()

	s.conf.Log.Info("Shutting down service", "users", len(s.users))
	s.users = nil

	return nil
}
{{else}}type Service struct {
	conf ServiceConfig
}

func NewService(conf ServiceConfig) (ServiceInterface, error) {
	// TODO: Initialize your service dependencies here
	return &Service{conf: conf}, nil
}
{{range .Operations}}
func (s *Service) {{.MethodName}}(ctx context.Context, req *{{.RequestType}}, resp *{{.ResponseType}}) error {
	// TODO: Implement {{.MethodName}} logic
	return duh.NewServiceError(duh.CodeNotImplemented, "{{.MethodName}} not implemented", nil, nil)
}
{{end}}
func (s *Service) Shutdown(ctx context.Context) error {
	// TODO: Cleanup resources
	return nil
}
{{end}}