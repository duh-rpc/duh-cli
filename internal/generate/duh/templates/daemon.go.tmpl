// Code generated by 'duh generate duh --full' on {{.Timestamp}}. YOU CAN EDIT.

package {{.Package}}

import (
	"context"
	"crypto/tls"
	"errors"
	"fmt"
	"log/slog"
	"net"
	"net/http"
	"sync"
	"time"

	"github.com/duh-rpc/duh.go"
	"github.com/kapetan-io/tackle/set"
	"golang.org/x/net/netutil"
)

type DaemonConfig struct {
	// See Configuration for the service
	ServiceConfig ServiceConfig
	// ListenAddress is in 'address:port'
	ListenAddress string
	// Optional TLS config for the server
	ServerTLS *tls.Config
	// Optional TLS config for the client
	ClientTLS *tls.Config
	// Log is the logger to use
	Log slog.Logger
	// InstanceID is a unique id for this daemon instance
	InstanceID string
	// MaxConcurrentRequests is the maximum number of concurrent HTTP requests allowed.
	MaxConcurrentRequests int
}

type Daemon struct {
	service  ServiceInterface
	client   ClientInterface
	server   *http.Server
	wg       sync.WaitGroup
	Listener net.Listener
	conf     DaemonConfig
}

func SpawnDaemon(ctx context.Context, conf DaemonConfig) (*Daemon, error) {
	// Set daemon defaults if not defined by the config
	set.Default(&conf.InstanceID, fmt.Sprintf("daemon-%d", time.Now().UnixNano()))
	set.Default(&conf.MaxConcurrentRequests, 1000)
	if conf.Log.Handler() == nil {
		conf.Log = *slog.Default()
	}

	// Set service defaults if not defined by the config
	set.Default(&conf.ServiceConfig.InstanceID, conf.InstanceID)
	if conf.ServiceConfig.Log == nil {
		conf.ServiceConfig.Log = slog.Default()
	}

	s, err := NewService(conf.ServiceConfig)
	if err != nil {
		return nil, err
	}

	d := &Daemon{
		conf:    conf,
		service: s,
	}
	handler := NewHandler(d.service, HandlerConfig{})

	if d.conf.ServerTLS != nil {
		if err := d.spawnHTTPS(ctx, handler); err != nil {
			return nil, err
		}
	} else {
		if err := d.spawnHTTP(ctx, handler); err != nil {
			return nil, err
		}
	}
	return d, nil
}

func (d *Daemon) Shutdown(ctx context.Context) error {
	if err := d.service.Shutdown(ctx); err != nil {
		return err
	}

	d.conf.Log.LogAttrs(ctx, slog.LevelWarn,
		"Shutting down HTTP server", slog.String("address", d.server.Addr))
	_ = d.server.Shutdown(ctx)
	d.conf.Log.Info("HTTP Server shutdown", "address", d.server.Addr)
	return nil
}

func (d *Daemon) Service() ServiceInterface {
	return d.service
}

func (d *Daemon) MustClient() ClientInterface {
	c, err := d.Client()
	if err != nil {
		panic(fmt.Sprintf("[%s] failed to init daemon client - '%s'", d.conf.InstanceID, err))
	}
	return c
}

func (d *Daemon) Client() (ClientInterface, error) {
	// Original logic for non-InMemoryListener clients
	var err error
	if d.client != nil {
		return d.client, nil
	}

	if d.conf.ClientTLS != nil {
		d.client, err = NewClient(WithTLS(d.conf.ClientTLS, d.Listener.Addr().String()))
		return d.client, err
	}
	d.client, err = NewClient(WithNoTLS(d.Listener.Addr().String()))
	return d.client, err
}

func (d *Daemon) spawnHTTPS(ctx context.Context, mux http.Handler) error {
	srv := &http.Server{
		ErrorLog:  slog.NewLogLogger(d.conf.Log.Handler(), slog.LevelError),
		TLSConfig: d.conf.ServerTLS,
		Addr:      d.conf.ListenAddress,
		Handler:   mux,
	}

	var err error
	l, err := net.Listen("tcp", d.conf.ListenAddress)
	if err != nil {
		return fmt.Errorf("while starting HTTPS listener: %w", err)
	}
	d.Listener = netutil.LimitListener(l, d.conf.MaxConcurrentRequests)
	srv.Addr = d.Listener.Addr().String()

	d.wg.Add(1)
	go func() {
		defer d.wg.Done()
		d.conf.Log.Info("HTTPS Listening ...", "address", d.Listener.Addr().String())
		if err := srv.ServeTLS(d.Listener, "", ""); err != nil {
			if !errors.Is(err, http.ErrServerClosed) {
				d.conf.Log.Error("while starting TLS HTTP server", "error", err)
			}
		}
	}()
	if err := duh.WaitForConnect(ctx, d.Listener.Addr().String(), d.conf.ClientTLS); err != nil {
		return err
	}
	d.server = srv

	return nil
}

func (d *Daemon) spawnHTTP(ctx context.Context, h http.Handler) error {
	srv := &http.Server{
		ErrorLog: slog.NewLogLogger(d.conf.Log.Handler(), slog.LevelError),
		Addr:     d.conf.ListenAddress,
		Handler:  h,
	}
	var err error
	l, err := net.Listen("tcp", d.conf.ListenAddress)
	if err != nil {
		return fmt.Errorf("while starting HTTP listener: %w", err)
	}
	// Limit the number of concurrent connections allowed to avoid abusing our resources.
	d.Listener = netutil.LimitListener(l, d.conf.MaxConcurrentRequests)
	srv.Addr = d.Listener.Addr().String()

	d.wg.Add(1)
	go func() {
		defer d.wg.Done()
		if err := srv.Serve(d.Listener); err != nil {
			if !errors.Is(err, http.ErrServerClosed) {
				d.conf.Log.Error("while starting HTTP server", "error", err)
			}
		}
	}()

	if err := duh.WaitForConnect(ctx, d.Listener.Addr().String(), nil); err != nil {
		return err
	}

	d.conf.Log.Info("HTTP Server Started", "address", d.Listener.Addr().String())
	d.server = srv
	return nil
}
