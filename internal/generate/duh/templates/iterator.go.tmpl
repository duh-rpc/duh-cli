// Code generated by 'duh generate' on {{.Timestamp}}. DO NOT EDIT.

package {{.Package}}

import (
	"context"
)

// Page represents a page of results from paginated API
type Page[T any] struct {
	Items      []T
	Total      int
	Page       int
	PerPage    int
	TotalPages int
}

// Iterator provides iteration over paginated API resources
type Iterator[T any] interface {
	Next(ctx context.Context, page *Page[T]) bool
	Err() error
}

// PageFetcher defines how to fetch pages of data
type PageFetcher[T any] interface {
	FetchPage(ctx context.Context, pageNum int) (*Page[T], error)
}

// GenericIterator implements Iterator for any paginated resource
type GenericIterator[T any] struct {
	fetcher     PageFetcher[T]
	currentPage int
	totalPages  int
	err         error
	initialized bool
}

// NewGenericIterator creates a new iterator for paginated resources
func NewGenericIterator[T any](fetcher PageFetcher[T]) *GenericIterator[T] {
	return &GenericIterator[T]{
		fetcher: fetcher,
	}
}

// Next fetches the next page of results
// Returns false when no more pages or context cancelled
// Check Err() for context cancellation or other errors
func (it *GenericIterator[T]) Next(ctx context.Context, page *Page[T]) bool {
	select {
	case <-ctx.Done():
		it.err = ctx.Err()
		return false
	default:
	}

	if !it.initialized {
		it.currentPage = 0
		it.initialized = true
	}

	if it.totalPages > 0 && it.currentPage >= it.totalPages {
		return false
	}

	it.currentPage++
	fetchedPage, err := it.fetcher.FetchPage(ctx, it.currentPage)
	if err != nil {
		it.err = err
		return false
	}

	if it.currentPage == 1 {
		it.totalPages = fetchedPage.TotalPages
	}

	*page = *fetchedPage

	return it.currentPage <= it.totalPages
}

// Err returns any error encountered during iteration
func (it *GenericIterator[T]) Err() error {
	return it.err
}
