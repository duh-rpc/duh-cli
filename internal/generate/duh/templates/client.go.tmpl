// Code generated by 'duh generate' on {{.Timestamp}}. DO NOT EDIT.

package {{.Package}}

import (
	"bytes"
	"context"
	"crypto/tls"
	"errors"
	"fmt"
	"net/http"

	"github.com/duh-rpc/duh.go"
	pb "{{.ProtoImport}}"
	"github.com/kapetan-io/tackle/clock"
	"github.com/kapetan-io/tackle/set"
	"google.golang.org/protobuf/proto"
)

type ClientInterface interface {
{{- range .Operations}}
	{{if .Summary}}// {{.Summary}}{{end}}
	{{.MethodName}}(ctx context.Context, req *{{.RequestType}}, resp *{{.ResponseType}}) error
{{- end}}
	// Close the client
	Close(ctx context.Context) error
}

type ClientConfig struct {
	// Users can provide their own http client with TLS config if needed
	Client *http.Client
	// The address of endpoint in the format `<scheme>://<host>:<port>`
	Endpoint string
}

type Client struct {
	client *duh.Client
	conf   ClientConfig
}

// NewClient creates a new instance of the Gubernator user client
func NewClient(conf ClientConfig) (*Client, error) {
	set.Default(&conf.Client, &http.Client{
		Transport: &http.Transport{
			MaxConnsPerHost:     5_000,
			MaxIdleConns:        5_000,
			MaxIdleConnsPerHost: 5_000,
			IdleConnTimeout:     60 * clock.Second,
		},
	})

	if len(conf.Endpoint) == 0 {
		return nil, errors.New("conf.Endpoint is empty; must provide an http endpoint")
	}

	return &Client{
		client: &duh.Client{
			Client: conf.Client,
		},
		conf: conf,
	}, nil
}
{{range .Operations}}
func (c *Client) {{.MethodName}}(ctx context.Context, req *{{.RequestType}}, resp *{{.ResponseType}}) error {
	payload, err := proto.Marshal(req)
	if err != nil {
		return duh.NewClientError("while marshaling request payload: %w", err, nil)
	}

	r, err := http.NewRequestWithContext(ctx, http.MethodPost,
		fmt.Sprintf("%s%s", c.conf.Endpoint, {{.ConstName}}), bytes.NewReader(payload))
	if err != nil {
		return duh.NewClientError("", err, nil)
	}

	r.Header.Set("Content-Type", duh.ContentTypeProtoBuf)
	return c.client.Do(r, resp)
}
{{end}}
func (c *Client) Close(ctx context.Context) error {
	c.client.Client.CloseIdleConnections()
	return nil
}

{{if .HasListOps}}
{{range .ListOps}}
// {{.FetcherName}} implements PageFetcher for {{.MethodName}} pagination
type {{.FetcherName}} struct {
	client *Client
	limit  int32
}

// FetchPage fetches a specific page of {{.ResponseField}} by converting page number to offset
func (f *{{.FetcherName}}) FetchPage(ctx context.Context, pageNum int) (*Page[{{.ItemType}}], error) {
	offset := int32((pageNum - 1) * int(f.limit))

	var resp {{.ResponseType}}
	err := f.client.{{.MethodName}}(ctx, &{{.RequestType}}{
		Offset: offset,
		Limit:  f.limit,
	}, &resp)
	if err != nil {
		return nil, err
	}

	totalPages := int(resp.Total) / int(f.limit)
	if int(resp.Total)%int(f.limit) != 0 {
		totalPages++
	}

	return &Page[{{.ItemType}}]{
		Items:      resp.{{.ResponseField}},
		Total:      int(resp.Total),
		Page:       pageNum,
		PerPage:    int(f.limit),
		TotalPages: totalPages,
	}, nil
}

// {{.IteratorName}} creates an iterator for paginating through {{.ResponseField}}
func (c *Client) {{.IteratorName}}(limit int32) Iterator[{{.ItemType}}] {
	if limit <= 0 {
		limit = 10
	}

	fetcher := &{{.FetcherName}}{
		client: c,
		limit:  limit,
	}

	return NewGenericIterator[{{.ItemType}}](fetcher)
}
{{end}}
{{end}}

// WithTLS returns ClientConfig suitable for use with TLS clients
func WithTLS(tls *tls.Config, address string) ClientConfig {
	return ClientConfig{
		Endpoint: fmt.Sprintf("https://%s", address),
		Client: &http.Client{
			Transport: &http.Transport{
				TLSClientConfig:     tls,
				MaxConnsPerHost:     2_000,
				MaxIdleConns:        2_000,
				MaxIdleConnsPerHost: 2_000,
				IdleConnTimeout:     60 * clock.Second,
			},
		},
	}
}

// WithNoTLS returns ClientConfig suitable for use with NON-TLS clients
func WithNoTLS(address string) ClientConfig {
	return ClientConfig{
		Endpoint: fmt.Sprintf("http://%s", address),
		Client: &http.Client{
			Transport: &http.Transport{
				MaxConnsPerHost:     2_000,
				MaxIdleConns:        2_000,
				MaxIdleConnsPerHost: 2_000,
				IdleConnTimeout:     60 * clock.Second,
			},
		},
	}
}
