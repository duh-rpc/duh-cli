// Code generated by 'duh generate' on {{.Timestamp}}. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	"net/http"
	pb "{{.ProtoImport}}"

	"github.com/duh-rpc/duh-go"
)

const (
{{- range .Operations}}
	{{.ConstName}} = "{{.Path}}"
{{- end}}
)

// ServiceInterface represents all server handlers.
type ServiceInterface interface {
{{- range .Operations}}
	{{if .Summary}}// {{.Summary}}{{end}}
	{{.MethodName}}(ctx context.Context, req *{{.RequestType}}, resp *{{.ResponseType}}) error
{{- end}}
	// Shutdown the service, this is called when the daemon is shutting down.
	Shutdown(ctx context.Context) error
}

type MiddlewareFunc func(http.Handler) http.Handler

type HandlerConfig struct {
	Middlewares []MiddlewareFunc
}

func NewHandler(s ServiceInterface, conf HandlerConfig) http.Handler {
	h := Handler{Service: s}
	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		h.ServeHTTP(w, r)
	}))

	for _, middleware := range conf.Middlewares {
	handler = middleware(handler)
	}
	return handler
}

type Handler struct {
	Service ServiceInterface
}

func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		duh.ReplyWithCode(w, r, duh.CodeBadRequest, nil,
			fmt.Sprintf("http method '%s' not allowed; only POST", r.Method))
		return
	}

	// No need for fancy routers, a switch case is performant and simple.
	switch r.URL.Path {
{{- range .Operations}}
	case {{.ConstName}}:
		h.handle{{.MethodName}}(w, r)
		return
{{- end}}
	}
	duh.ReplyWithCode(w, r, duh.CodeNotImplemented, nil, "no such method; "+r.URL.Path)
}
{{range .Operations}}
func (h *Handler) handle{{.MethodName}}(w http.ResponseWriter, r *http.Request) {
	var req {{.RequestType}}
	if err := duh.ReadRequest(r, &req, 5*duh.MegaByte); err != nil {
		duh.ReplyError(w, r, err)
		return
	}
	var resp {{.ResponseType}}
	if err := h.Service.{{.MethodName}}(r.Context(), &req, &resp); err != nil {
		duh.ReplyError(w, r, err)
		return
	}
	duh.Reply(w, r, duh.CodeOK, &resp)
}
{{end}}