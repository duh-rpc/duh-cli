// Code generated by 'duh generate duh --full' on {{.Timestamp}}. YOU CAN EDIT.

package {{.Package}}_test

import (
	"context"
	"testing"
	"time"

	"{{.PackageImport}}"
	pb "{{.ProtoImport}}"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

{{if .IsFullTemplate}}{{- $createMethod := "" -}}
{{- $getMethod := "" -}}
{{- $listMethod := "" -}}
{{- $updateMethod := "" -}}
{{- range .Operations -}}
  {{- if eq .Path "/v1/users.create" -}}{{- $createMethod = .MethodName -}}{{- end -}}
  {{- if eq .Path "/v1/users.get" -}}{{- $getMethod = .MethodName -}}{{- end -}}
  {{- if eq .Path "/v1/users.list" -}}{{- $listMethod = .MethodName -}}{{- end -}}
  {{- if eq .Path "/v1/users.update" -}}{{- $updateMethod = .MethodName -}}{{- end -}}
{{- end -}}

func TestUsersCreate(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient()

	var resp pb.CreateUserResponse
	err = c.{{$createMethod}}(ctx, &pb.CreateUserRequest{
		Name:  "Alice",
		Email: "alice@example.com",
		Age:   30,
	}, &resp)
	require.NoError(t, err)
	assert.NotEmpty(t, resp.UserId)
	assert.Equal(t, "alice@example.com", resp.Email)
	assert.Equal(t, "Alice", resp.Name)
	assert.NotNil(t, resp.CreatedAt)
}

func TestUsersCreateValidation(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient()

	for _, test := range []struct {
		name    string
		request *pb.CreateUserRequest
		wantErr string
	}{
		{
			name: "MissingEmail",
			request: &pb.CreateUserRequest{
				Name: "Alice",
			},
			wantErr: "email is required",
		},
		{
			name: "MissingName",
			request: &pb.CreateUserRequest{
				Email: "alice@example.com",
			},
			wantErr: "name is required",
		},
	} {
		t.Run(test.name, func(t *testing.T) {
			var resp pb.CreateUserResponse
			err := c.{{$createMethod}}(ctx, test.request, &resp)
			require.Error(t, err)
			require.ErrorContains(t, err, test.wantErr)
		})
	}
}

func TestUsersCreateDuplicateEmail(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient()

	var resp1 pb.CreateUserResponse
	err = c.{{$createMethod}}(ctx, &pb.CreateUserRequest{
		Name:  "Alice",
		Email: "alice@example.com",
	}, &resp1)
	require.NoError(t, err)

	var resp2 pb.CreateUserResponse
	err = c.{{$createMethod}}(ctx, &pb.CreateUserRequest{
		Name:  "Alice2",
		Email: "alice@example.com",
	}, &resp2)
	require.Error(t, err)
	require.ErrorContains(t, err, "user with this email already exists")
}

func TestUsersGet(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient()

	var created pb.CreateUserResponse
	err = c.{{$createMethod}}(ctx, &pb.CreateUserRequest{
		Name:  "Bob",
		Email: "bob@example.com",
		Age:   25,
	}, &created)
	require.NoError(t, err)

	var resp pb.UserResponse
	err = c.{{$getMethod}}(ctx, &pb.GetUserRequest{
		UserId: created.UserId,
	}, &resp)
	require.NoError(t, err)
	assert.Equal(t, created.UserId, resp.UserId)
	assert.Equal(t, "bob@example.com", resp.Email)
	assert.Equal(t, "Bob", resp.Name)
	assert.Equal(t, int32(25), resp.Age)
}

func TestUsersGetNotFound(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient()

	var resp pb.UserResponse
	err = c.{{$getMethod}}(ctx, &pb.GetUserRequest{
		UserId: "nonexistent-id",
	}, &resp)
	require.Error(t, err)
	require.ErrorContains(t, err, "user not found")
}

func TestUsersGetValidation(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient()

	var resp pb.UserResponse
	err = c.{{$getMethod}}(ctx, &pb.GetUserRequest{
		UserId: "",
	}, &resp)
	require.Error(t, err)
	require.ErrorContains(t, err, "user_id is required")
}

func TestUsersList(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient()

	const numUsers = 5
	for i := 0; i < numUsers; i++ {
		var resp pb.CreateUserResponse
		err = c.{{$createMethod}}(ctx, &pb.CreateUserRequest{
			Name:  "User" + string(rune('A'+i)),
			Email: "user" + string(rune('a'+i)) + "@example.com",
		}, &resp)
		require.NoError(t, err)
	}

	var resp pb.ListUsersResponse
	err = c.{{$listMethod}}(ctx, &pb.ListUsersRequest{}, &resp)
	require.NoError(t, err)
	assert.Len(t, resp.Users, numUsers)
	assert.Equal(t, int32(numUsers), resp.Total)
}

func TestUsersListPagination(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient()

	const numUsers = 15
	for i := 0; i < numUsers; i++ {
		var resp pb.CreateUserResponse
		err = c.{{$createMethod}}(ctx, &pb.CreateUserRequest{
			Name:  "User" + string(rune('A'+i)),
			Email: "user" + string(rune('a'+i)) + "@example.com",
		}, &resp)
		require.NoError(t, err)
	}

	var page1 pb.ListUsersResponse
	err = c.{{$listMethod}}(ctx, &pb.ListUsersRequest{
		Limit:  10,
		Offset: 0,
	}, &page1)
	require.NoError(t, err)
	assert.Len(t, page1.Users, 10)
	assert.Equal(t, int32(numUsers), page1.Total)
	assert.True(t, page1.HasMore)

	var page2 pb.ListUsersResponse
	err = c.{{$listMethod}}(ctx, &pb.ListUsersRequest{
		Limit:  10,
		Offset: 10,
	}, &page2)
	require.NoError(t, err)
	assert.Len(t, page2.Users, 5)
	assert.Equal(t, int32(numUsers), page2.Total)
	assert.False(t, page2.HasMore)
}

func TestUsersListIterator(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient().(*api.Client)

	const numUsers = 25
	for i := 0; i < numUsers; i++ {
		var resp pb.CreateUserResponse
		err = c.{{$createMethod}}(ctx, &pb.CreateUserRequest{
			Name:  "User" + string(rune('A'+i)),
			Email: "user" + string(rune('a'+i)) + "@example.com",
		}, &resp)
		require.NoError(t, err)
	}

	iter := c.UsersListIter(10)
	var page api.Page[*pb.UserResponse]

	collected := make([]*pb.UserResponse, 0)
	pages := 0

	for iter.Next(ctx, &page) {
		pages++
		collected = append(collected, page.Items...)
		assert.Equal(t, numUsers, page.Total)
		assert.Equal(t, 10, page.PerPage)
	}

	require.NoError(t, iter.Err())
	assert.Equal(t, 3, pages)
	assert.Len(t, collected, numUsers)
}

func TestUsersListSorting(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient()

	users := []struct {
		name  string
		email string
	}{
		{"Charlie", "charlie@example.com"},
		{"Alice", "alice@example.com"},
		{"Bob", "bob@example.com"},
	}

	for _, u := range users {
		var resp pb.CreateUserResponse
		err = c.{{$createMethod}}(ctx, &pb.CreateUserRequest{
			Name:  u.name,
			Email: u.email,
		}, &resp)
		require.NoError(t, err)
	}

	var resp pb.ListUsersResponse
	err = c.{{$listMethod}}(ctx, &pb.ListUsersRequest{
		SortBy: pb.SortBy_SORT_BY_NAME,
	}, &resp)
	require.NoError(t, err)
	require.Len(t, resp.Users, 3)
	assert.Equal(t, "Alice", resp.Users[0].Name)
	assert.Equal(t, "Bob", resp.Users[1].Name)
	assert.Equal(t, "Charlie", resp.Users[2].Name)
}

func TestUsersUpdate(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient()

	var created pb.CreateUserResponse
	err = c.{{$createMethod}}(ctx, &pb.CreateUserRequest{
		Name:  "Alice",
		Email: "alice@example.com",
		Age:   30,
	}, &created)
	require.NoError(t, err)

	var updated pb.UpdateUserResponse
	err = c.{{$updateMethod}}(ctx, &pb.UpdateUserRequest{
		UserId: created.UserId,
		Name:   "Alice Updated",
		Age:    31,
	}, &updated)
	require.NoError(t, err)
	assert.Equal(t, created.UserId, updated.UserId)
	assert.Equal(t, "Alice Updated", updated.Name)
	assert.Equal(t, int32(31), updated.Age)
	assert.NotNil(t, updated.UpdatedAt)
}

func TestUsersUpdateNotFound(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient()

	var resp pb.UpdateUserResponse
	err = c.{{$updateMethod}}(ctx, &pb.UpdateUserRequest{
		UserId: "nonexistent-id",
		Name:   "Updated",
	}, &resp)
	require.Error(t, err)
	require.ErrorContains(t, err, "user not found")
}

func TestUsersUpdateDuplicateEmail(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient()

	var user1 pb.CreateUserResponse
	err = c.{{$createMethod}}(ctx, &pb.CreateUserRequest{
		Name:  "Alice",
		Email: "alice@example.com",
	}, &user1)
	require.NoError(t, err)

	var user2 pb.CreateUserResponse
	err = c.{{$createMethod}}(ctx, &pb.CreateUserRequest{
		Name:  "Bob",
		Email: "bob@example.com",
	}, &user2)
	require.NoError(t, err)

	var resp pb.UpdateUserResponse
	err = c.{{$updateMethod}}(ctx, &pb.UpdateUserRequest{
		UserId: user2.UserId,
		Email:  "alice@example.com",
	}, &resp)
	require.Error(t, err)
	require.ErrorContains(t, err, "user with this email already exists")
}

func TestUsersUpdateValidation(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient()

	var resp pb.UpdateUserResponse
	err = c.{{$updateMethod}}(ctx, &pb.UpdateUserRequest{
		UserId: "",
		Name:   "Updated",
	}, &resp)
	require.Error(t, err)
	require.ErrorContains(t, err, "user_id is required")
}
{{else}}{{$firstOp := index .Operations 0}}func Test{{$firstOp.MethodName}}(t *testing.T) {
	d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
	require.NoError(t, err)
	defer d.Shutdown(context.Background())

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	c := d.MustClient()

	// TODO: Create appropriate request for {{$firstOp.MethodName}}
	var req {{$firstOp.RequestType}}
	var resp {{$firstOp.ResponseType}}

	err = c.{{$firstOp.MethodName}}(ctx, &req, &resp)

	// TODO: Add appropriate assertions
	require.NoError(t, err)
	// assert.NotEmpty(t, resp.SomeField)
}

// TODO: Add more tests for your operations
{{end}}