# `--full` Flag Implementation Plan

## Overview

This plan adds a `--full` flag to the `duh generate duh` command that generates additional editable scaffolding files (daemon, service implementation, tests, and Makefile) alongside the standard generated code. The implementation includes smart template selection that detects whether the OpenAPI spec matches the `duh init` template and generates either full implementations or stubs accordingly.

## Current State Analysis

### Existing `duh generate duh` Command

Currently generates 4 files with "DO NOT EDIT" headers:
- **server.go** - HTTP server with routing (`internal/generate/duh/templates/server.go.tmpl`)
- **client.go** - HTTP client with methods (`internal/generate/duh/templates/client.go.tmpl`)
- **iterator.go** - Pagination iterators, conditional (`internal/generate/duh/templates/iterator.go.tmpl`)
- **proto file** - Protobuf definitions (via openapi-proto.go library)

**File**: `run_cmd.go:202-245`
- Flag definition: `duhCmd.Flags().StringP("package", "p", "api", "Package name for generated code")`
- Command execution: Calls `duh.Run()` from `internal/generate/duh/duh.go`

**File**: `internal/generate/duh/duh.go:12-100`
- Main orchestration function
- Validates spec, parses operations, generates files
- Uses `Generator` to render templates

### Reference Implementation Files

Located in `/Users/thrawn/Development/duh-poc/`:
- **daemon.go** - Line 1: `// Code generated by 'duh generate duh --full' YOU CAN EDIT.`
- **service.go** - Line 1: `// Code generated by 'duh generate duh --full' YOU CAN EDIT.`
- **api_test.go** - Line 1: `// Code generated by 'duh generate duh --full' YOU CAN EDIT.`
- **Makefile** - Line 1: `# Code generated by 'duh generate duh --full' YOU CAN EDIT.`

### Template Matching Logic

**`duh init` Template Endpoints** (`internal/init/template/openapi.yaml`):
1. `/v1/users.create` - operationId: createUser
2. `/v1/users.get` - operationId: getUserById
3. `/v1/users.list` - operationId: listUsers
4. `/v1/users.update` - operationId: updateUser

**Matching Rules:**
- The spec is considered a "full match" if it contains ALL 4 of these exact paths
- Additional endpoints beyond these 4 are allowed and don't affect the match
- If the spec has all 4 endpoints, full implementations are generated
- If ANY of the 4 endpoints are missing, stub implementations are generated

### Key Discoveries

- Template system uses `embed.FS` (`internal/generate/duh/embed.go:3-6`)
- Generator has timestamp generation (`internal/generate/duh/generator.go:64-66`)
- Existing templates use `{{.Timestamp}}` for timestamping (`templates/*.tmpl:1`)
- Parser extracts operation metadata into `TemplateData` struct

## Desired End State

Running `duh generate duh openapi.yaml --full` will:

1. Generate all standard files (server.go, client.go, iterator.go, proto)
2. Generate 4 additional editable files:
   - **daemon.go** - Daemon orchestration with TLS/HTTP support
   - **service.go** - Service implementation (full or stub based on spec)
   - **api_test.go** - Integration tests (full suite or minimal example)
   - **Makefile** - Build automation
3. Detect if spec contains all 4 `duh init` template endpoints:
   - **Has all 4**: Generate full implementations with in-memory map and complete tests
   - **Missing any**: Generate stub implementations with TODO comments and minimal test example
4. All `--full` files have header: `// Code generated by 'duh generate duh --full' on 2025-10-26 12:34:56 UTC. YOU CAN EDIT.` (with actual timestamp)
5. Always overwrite existing files when regenerating (manual edits will be lost)

### Verification

Run these commands to verify:
```bash
# Test with duh init template (should generate full implementations)
duh init openapi.yaml
duh generate duh openapi.yaml --full
# Check that service.go has in-memory map implementation
# Check that api_test.go has full test suite

# Test with custom spec (should generate stubs)
cat > custom.yaml <<EOF
openapi: 3.0.3
info:
  title: Custom API
  version: 1.0.0
paths:
  /v1/products.create:
    post:
      operationId: createProduct
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
      responses:
        '200':
          description: Success
          content:
            application/json:
              schema:
                type: object
EOF
duh generate duh custom.yaml --full
# Check that service.go has TODO stubs
# Check that api_test.go has minimal example

# Verify all files generated
ls -la | grep -E "(daemon|service|api_test|Makefile)"

# Run the generated code
go test ./...
```

## What We're NOT Doing

- NOT adding customization options for file names (always daemon.go, service.go, etc.)
- NOT generating documentation files beyond code comments
- NOT modifying existing non-`--full` behavior
- NOT adding a separate `--full-with-tests` flag
- NOT preserving manual edits on regeneration (files are always overwritten)
- NOT validating presence of buf.gen.yaml or buf.yaml (user must set these up separately)

## Implementation Approach

The implementation follows these principles:

1. **Minimal Flag Addition**: Add boolean `--full` flag to existing command
2. **Template Reuse**: Leverage existing template system and embed.FS pattern
3. **Smart Detection**: Check spec paths against `duh init` template paths
4. **Conditional Rendering**: Use Go template conditionals for full vs stub generation
5. **Consistent Headers**: Reuse timestamp generation with "YOU CAN EDIT" suffix

## Phase 1: Add --full Flag and Spec Detection

### Overview
Add the `--full` flag to the CLI command and implement logic to detect whether the OpenAPI spec matches the `duh init` template.

### Changes Required

#### 1. CLI Flag Addition

**File**: `run_cmd.go`

**Changes**: Add `--full` flag to duhCmd

```go
func RunCmd(stdout io.Writer, args []string) int
```

**Function Responsibilities:**
- Add boolean flag: `duhCmd.Flags().Bool("full", false, "Generate additional editable scaffolding files")`
- Read flag value: `fullFlag, _ := cmd.Flags().GetBool("full")`
- Pass flag value to `duh.Run()` as second-to-last parameter (before converter)
- Updated call: `duh.Run(cmd.OutOrStdout(), filePath, packageName, outputDir, protoPath, protoImport, protoPackage, fullFlag, converter)`

#### 2. Spec Matching Detection

**File**: `internal/generate/duh/matcher.go` (new file)

**Changes**: Create spec matcher

```go
func IsInitTemplateSpec(spec *libopenapi.DocumentModel[v3.Document]) bool
```

**Function Responsibilities:**
- Extract paths from OpenAPI spec document
- Check if spec contains ALL of these 4 required paths:
  - `/v1/users.create`
  - `/v1/users.get`
  - `/v1/users.list`
  - `/v1/users.update`
- Return true if ALL 4 paths exist (additional paths are allowed, order doesn't matter)
- Return false if ANY of the 4 required paths is missing

**Context for Implementation:**
- Use existing spec loading from `internal/lint/lint.go:11-24` (Load function)
- Access paths via: `spec.Model.Paths.PathItems`
- Path matching should be exact string comparison
- Follow pattern from `internal/generate/duh/parser.go` for accessing spec data

#### 3. Update Main Orchestration

**File**: `internal/generate/duh/duh.go`

**Changes**: Add `fullFlag` parameter and spec matching

```go
func Run(w io.Writer, specPath, packageName, outputDir, protoPath, protoImport, protoPackage string, fullFlag bool, converter ProtoConverter) error
```

**Function Responsibilities:**
- Accept new `fullFlag bool` parameter
- After spec validation, detect if spec matches template: `isFullTemplate := IsInitTemplateSpec(spec)`
- Store both `fullFlag` and `isFullTemplate` in data structure for template use
- Pass to generator for conditional file generation
- Follow existing error handling pattern from lines 14-21

**Context for Implementation:**
- Spec is already loaded at line 13-16
- Add matching check after line 21 (after validation)
- Will pass flags to generator in Phase 2

### Testing Requirements

**File**: `internal/generate/duh/matcher_test.go` (new file)

**New Tests:**

```go
func TestIsInitTemplateSpecWithFullMatch(t *testing.T)
func TestIsInitTemplateSpecWithPartialMatch(t *testing.T)
func TestIsInitTemplateSpecWithNoMatch(t *testing.T)
func TestIsInitTemplateSpecWithExtraEndpoints(t *testing.T)
```

**Test Objectives:**
- Verify all 4 required endpoints present returns true
- Verify missing any single required endpoint returns false
- Verify completely different endpoints return false
- Verify extra endpoints beyond the 4 still returns true (as long as all 4 required are present)

**Context for Implementation:**
- Follow test pattern from `internal/generate/duh/config_test.go:140-217`
- Use `setupTest()` helper to create temp directories
- Use functional testing style: call `duh.RunCmd()` (per CLAUDE.md)
- Create test OpenAPI specs inline as strings

**File**: `internal/generate/duh/duh_test.go` (updates to existing or new file)

**Updated Tests:**

```go
func TestRunWithFullFlagFalse(t *testing.T)  // May need updates: verify --full flag is passed correctly
```

**Test Objectives:**
- Verify --full=false doesn't generate additional files
- Verify existing behavior unchanged without flag

### Validation Commands

```bash
go test ./internal/generate/duh -v -run TestIsInitTemplateSpec
go test ./internal/generate/duh -v -run TestRunWithFullFlag
```

## Phase 2: Create Template Files for --full Generation

### Overview
Create Go templates for the 4 additional files (daemon.go, service.go, api_test.go) and a Makefile template. Each template will support conditional rendering for full vs stub implementations.

### Changes Required

#### 1. Daemon Template

**File**: `internal/generate/duh/templates/daemon.go.tmpl` (new file)

**Template Structure:**
```go
// Code generated by 'duh generate duh --full' on {{.Timestamp}}. YOU CAN EDIT.

package {{.Package}}
// ... daemon implementation
```

**Template Content:**
- Copy structure from `/Users/thrawn/Development/duh-poc/daemon.go`
- Replace hardcoded package name with `{{.Package}}`
- Replace proto import with `{{.ProtoImport}}`
- Include full implementation (no conditionals needed - same for all specs)
- DaemonConfig struct with ServiceConfig, TLS, logging
- SpawnDaemon function with HTTP/HTTPS server setup
- Client() and MustClient() methods
- Shutdown() method

**Context for Implementation:**
- Reference existing templates: `templates/server.go.tmpl`, `templates/client.go.tmpl`
- Use `{{.Timestamp}}` for timestamp generation
- Proto import pattern: `pb "{{.ProtoImport}}"`

#### 2. Service Template (Conditional)

**File**: `internal/generate/duh/templates/service.go.tmpl` (new file)

**Template Structure:**
```go
// Code generated by 'duh generate duh --full' on {{.Timestamp}}. YOU CAN EDIT.

package {{.Package}}
// ... service implementation
```

**Template Content - Full Implementation Block:**
```go
{{if .IsFullTemplate}}
// Full in-memory implementation from /Users/thrawn/Development/duh-poc/service.go
// - ServiceConfig struct with InstanceID and Log
// - Service struct with users map[string]*pb.UserResponse
// - Full CRUD implementation for all 4 operations
// - Mutex-based concurrency control
// - Business logic validation
{{end}}
```

**Template Content - Stub Implementation Block:**
```go
{{if not .IsFullTemplate}}
type ServiceConfig struct {
    InstanceID string
    Log        *slog.Logger
}

type Service struct {
    conf ServiceConfig
}

func NewService(conf ServiceConfig) (ServiceInterface, error) {
    // TODO: Initialize your service dependencies here
    return &Service{conf: conf}, nil
}
{{range .Operations}}
func (s *Service) {{.MethodName}}(ctx context.Context, req *pb.{{.RequestType}}, resp *pb.{{.ResponseType}}) error {
    // TODO: Implement {{.MethodName}} logic
    return duh.NewServiceError(duh.CodeNotImplemented, "{{.MethodName}} not implemented", nil, nil)
}
{{end}}
func (s *Service) Shutdown(ctx context.Context) error {
    // TODO: Cleanup resources
    return nil
}
{{end}}
```

**Context for Implementation:**
- Use existing operation iteration pattern from `templates/server.go.tmpl:22-27`
- Reference `/Users/thrawn/Development/duh-poc/service.go` for full implementation
- Include imports: context, log/slog, sync (for full impl), duh.go, proto import, uuid, set

#### 3. Test Template (Conditional)

**File**: `internal/generate/duh/templates/api_test.go.tmpl` (new file)

**Template Structure:**
```go
// Code generated by 'duh generate duh --full' on {{.Timestamp}}. YOU CAN EDIT.

package {{.Package}}_test
// ... test implementation
```

**Template Content - Full Test Suite:**
```go
{{if .IsFullTemplate}}
// Full test suite from /Users/thrawn/Development/duh-poc/api_test.go
// Tests for all 4 operations: Create, Get, List, Update
// Validation tests
// Pagination tests
// Error case tests
{{end}}
```

**Template Content - Minimal Example:**
```go
{{if not .IsFullTemplate}}
import (
    "context"
    "testing"
    "time"

    "{{.GoModule}}/{{.Package}}"
    pb "{{.ProtoImport}}"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

{{$firstOp := index .Operations 0}}
func Test{{$firstOp.MethodName}}(t *testing.T) {
    d, err := {{$.Package}}.SpawnDaemon(context.Background(), {{$.Package}}.DaemonConfig{})
    require.NoError(t, err)
    defer d.Shutdown(context.Background())

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    c := d.MustClient()

    // TODO: Create appropriate request for {{$firstOp.MethodName}}
    var req {{$firstOp.RequestType}}
    var resp {{$firstOp.ResponseType}}

    err = c.{{$firstOp.MethodName}}(ctx, &req, &resp)

    // TODO: Add appropriate assertions
    require.NoError(t, err)
    // assert.NotEmpty(t, resp.SomeField)
}

// TODO: Add more tests for your operations
{{end}}
```

**Context for Implementation:**
- Need to add `GoModule` field to TemplateData (extracted from go.mod)
- Use `{{index .Operations 0}}` to get first operation for example
- Reference `/Users/thrawn/Development/duh-poc/api_test.go` for full suite
- Follow functional testing pattern from `internal/generate/duh/integration_test.go`

#### 4. Makefile Template

**File**: `internal/generate/duh/templates/Makefile.tmpl` (new file)

**Template Structure:**
```makefile
# Code generated by 'duh generate duh --full' on {{.Timestamp}}. YOU CAN EDIT.

.PHONY: test lint build clean proto tidy ci coverage
# ... makefile targets
```

**Template Content:**
- Copy structure from `/Users/thrawn/Development/duh-poc/Makefile`
- No conditionals needed (same for all specs)
- Include targets: proto, test, lint, build, clean, tidy, ci, coverage
- Proto generation uses `buf generate`
- Test runs `go test -v ./...`
- Lint uses `golangci-lint run ./...`

**Context for Implementation:**
- This is a text file, not Go code
- Use template header with `#` comment style
- Makefile should be in root of output directory

#### 5. Update TemplateData Structure

**File**: `internal/generate/duh/types.go`

**Changes**: Add new fields to TemplateData

```go
type TemplateData struct {
    // ... existing fields
    IsFullTemplate bool   // Whether spec matches duh init template
    GoModule       string // Go module path from go.mod
}
```

**Function Responsibilities:**
- Add `IsFullTemplate` field for conditional rendering
- Add `GoModule` field for test imports
- Both fields populated by parser or config

**Context for Implementation:**
- Existing struct at `types.go:8-20` (approximate)
- GoModule extraction logic needed in Phase 3

### Testing Requirements

**File**: `internal/generate/duh/templates_test.go` (new file)

**New Tests:**

```go
func TestDaemonTemplateRenders(t *testing.T)
func TestServiceTemplateRendersFullImpl(t *testing.T)
func TestServiceTemplateRendersStubs(t *testing.T)
func TestApiTestTemplateRendersFull(t *testing.T)
func TestApiTestTemplateRendersMinimal(t *testing.T)
func TestMakefileTemplateRenders(t *testing.T)
```

**Test Objectives:**
- Verify each template renders without errors
- Verify conditional blocks render correctly based on IsFullTemplate
- Verify all template variables are substituted
- Verify generated code/Makefile has valid syntax

**Context for Implementation:**
- Create mock TemplateData with required fields
- Use Generator.RenderX methods (will be added in Phase 3)
- Verify rendered output contains expected strings
- For Go templates, verify code compiles with `go/format`

### Validation Commands

```bash
go test ./internal/generate/duh -v -run TestDaemonTemplate
go test ./internal/generate/duh -v -run TestServiceTemplate
go test ./internal/generate/duh -v -run TestApiTestTemplate
go test ./internal/generate/duh -v -run TestMakefileTemplate
```

## Phase 3: Integrate Templates into Generator

### Overview
Add render methods to the Generator for the new templates, extract go.mod module path, and wire up the full generation flow in the main Run function.

### Changes Required

#### 1. Add Render Methods to Generator

**File**: `internal/generate/duh/generator.go`

**Changes**: Add render methods for new templates

```go
func (g *Generator) RenderDaemon(data *TemplateData) ([]byte, error)
func (g *Generator) RenderService(data *TemplateData) ([]byte, error)
func (g *Generator) RenderApiTest(data *TemplateData) ([]byte, error)
func (g *Generator) RenderMakefile(data *TemplateData) ([]byte, error)
```

**Function Responsibilities:**
- Set `data.Timestamp = g.timestamp` (reuse existing timestamp)
- Execute appropriate template: `g.templates.ExecuteTemplate(&buf, "daemon.go.tmpl", data)`
- For Go files: call `g.FormatCode(buf.Bytes())` to format
- For Makefile: return raw bytes (no formatting)
- Return formatted/raw bytes and any errors
- Follow existing pattern from `RenderServer`, `RenderClient`, `RenderIterator` (lines 27-57)

**Context for Implementation:**
- Templates loaded via embed.FS in `NewGenerator()` (line 16)
- Timestamp generated once per Generator (line 23)
- Makefile doesn't need go/format (it's not Go code)

#### 2. Go Module Path Extraction

**No new code needed** - Will reuse existing `Config.DetectModulePath()` method

**File**: `internal/generate/duh/config.go:63-87`

**Existing Function:**
```go
func (c *Config) DetectModulePath() (string, error)
```

**Function Behavior:**
- Reads `go.mod` from current working directory
- Parses module declaration line
- Returns module path (e.g., "github.com/duh-rpc/example.go")
- Returns error if go.mod not found or module line not found

**Context for Implementation:**
- Already implemented and tested
- Called from parser to populate GoModule field in TemplateData

#### 3. Update Parser to Set New Fields

**File**: `internal/generate/duh/parser.go`

**Changes**: Populate IsFullTemplate and GoModule

```go
func (p *Parser) Parse() (*TemplateData, error)
```

**Function Responsibilities:**
- After existing parsing logic, add: `data.IsFullTemplate = p.isFullTemplate`
- Extract go module: `data.GoModule, err = p.config.DetectModulePath()`
- Handle error if go.mod not found
- Return complete TemplateData with all fields populated

**Context for Implementation:**
- Parser already populates TemplateData (line 40-70 approximate)
- Config has OutputDir field from `config.go`
- Need to pass `isFullTemplate` to parser (from duh.Run)

#### 4. Update Parser Struct and Constructor

**File**: `internal/generate/duh/parser.go`

**Changes**: Add isFullTemplate field and update constructor

**Add field to Parser struct:**
```go
type Parser struct {
    spec           *libopenapi.DocumentModel[v3.Document]
    config         *Config
    isFullTemplate bool  // NEW FIELD
}
```

**Update constructor signature:**
```go
func NewParser(spec *libopenapi.DocumentModel[v3.Document], config *Config, isFullTemplate bool) *Parser
```

**Function Responsibilities:**
- Accept new `isFullTemplate bool` parameter
- Store isFullTemplate in Parser struct: `isFullTemplate: isFullTemplate`
- Return parser with all fields initialized

**Context for Implementation:**
- Current Parser struct at `parser.go:13-16` (approximate)
- Current constructor at `parser.go:25-30` (approximate)
- This field enables Parse() to set `data.IsFullTemplate`

#### 5. Update Main Run Function

**File**: `internal/generate/duh/duh.go`

**Changes**: Generate additional files when --full flag is set

```go
func Run(w io.Writer, specPath, packageName, outputDir, protoPath, protoImport, protoPackage string, fullFlag bool, converter ProtoConverter) error
```

**Function Responsibilities:**
- After proto file generation (around line 92), check `if fullFlag`
- If true, generate 4 additional files:
  - Call `generator.RenderDaemon(data)` → write to `filepath.Join(outputDir, "daemon.go")`
  - Call `generator.RenderService(data)` → write to `filepath.Join(outputDir, "service.go")`
  - Call `generator.RenderApiTest(data)` → write to `filepath.Join(outputDir, "api_test.go")`
  - Call `generator.RenderMakefile(data)` → write to `"Makefile"` (current directory, where go.mod is)
- Update filesGenerated list to include new files
- Update success message to reflect total files generated
- Follow existing error handling pattern from lines 39-92

**Context for Implementation:**
- Use existing `writeFile()` helper (line 102-108)
- Api test file is in same directory as other generated files, uses `package api_test`
- Makefile has no .go extension and goes to project root (current directory)
- Go files (daemon.go, service.go, api_test.go) go to outputDir

### Testing Requirements

**File**: `internal/generate/duh/full_integration_test.go` (new file)

**New Tests:**

```go
func TestGenerateDuhWithFullFlagAndInitSpec(t *testing.T)
func TestGenerateDuhWithFullFlagAndCustomSpec(t *testing.T)
func TestGenerateDuhWithoutFullFlag(t *testing.T)
func TestRegenerateWithFullFlagOverwrites(t *testing.T)
func TestMakefileGoesToProjectRoot(t *testing.T)
```

**Test Objectives:**
- Verify --full with init spec generates all 8 files (4 standard + 4 full)
- Verify service.go contains in-memory implementation (check for "map[string]")
- Verify api_test.go contains full test suite (check for multiple test functions)
- Verify --full with custom spec generates stub service.go (check for "TODO")
- Verify api_test.go contains minimal example (check for single test)
- Verify without --full only generates 4 standard files
- Verify regenerating with --full overwrites existing editable files (no preservation of manual edits)
- Verify Makefile is written to current directory (where go.mod is), not outputDir

**Context for Implementation:**
- Follow functional testing pattern from `internal/generate/duh/integration_test.go:276-625`
- Use `duh.RunCmd(&stdout, []string{"generate", "duh", specPath, "--full"})`
- Create test go.mod file in temp directory
- Use `os.ReadFile()` to verify file contents
- Use `strings.Contains()` for content checks

### Validation Commands

```bash
go test ./internal/generate/duh -v -run TestGenerateDuhWithFullFlag
go test ./internal/generate/duh -v -run TestRegenerateWithFullFlagOverwrites
go test ./internal/generate/duh -v -run TestMakefileGoesToProjectRoot
go test ./internal/generate/duh -v
```

## Phase 4: End-to-End Testing and Documentation

### Overview
Comprehensive testing of the complete feature with both init template specs and custom specs, plus verification that generated code compiles and runs.

### Changes Required

#### 1. Integration Test Suite

**File**: `internal/generate/duh/full_e2e_test.go` (new file)

**New Tests:**

```go
func TestFullGenerationWithInitSpecCompiles(t *testing.T)
func TestFullGenerationWithCustomSpecCompiles(t *testing.T)
func TestFullGeneratedTestsPass(t *testing.T)
func TestMakefileTargetsWork(t *testing.T)
```

**Test Objectives:**
- Generate code with `--full` flag using init template spec
- Run `go build` on generated code
- Verify all generated Go files compile successfully
- Run generated tests with `go test`
- Verify Makefile targets execute: `make test`, `make build`
- Repeat for custom spec to verify stubs compile

**Context for Implementation:**
- Follow pattern from `internal/generate/duh/integration_test.go:789-810`
- Use `exec.Command("go", "build", "./...")` to compile
- Use `exec.Command("go", "test", "./...")` to run tests
- Create complete go.mod in test temp directory
- Include necessary dependencies in test setup

#### 2. CLI Help Text Update

**File**: `run_cmd.go`

**Changes**: Update duhCmd.Long description

```go
Long: `Generate DUH-RPC client, server, and proto from OpenAPI specification.

The duh command generates DUH-RPC specific code including HTTP client with
pagination iterators, server with routing, and protobuf definitions.

By default, generates client.go, server.go, iterator.go (if list operations),
and proto file. Use flags to customize output.

With --full flag, additionally generates editable scaffolding files:
  - daemon.go: Service orchestration with TLS/HTTP support
  - service.go: Service implementation (full or stub based on spec)
  - api_test.go: Integration tests (full suite or minimal example)
  - Makefile: Build automation with test, lint, and proto targets

If the OpenAPI spec matches 'duh init' template (users.create, users.get,
users.list, users.update), full implementations are generated. Otherwise,
stub implementations with TODO comments are generated for you to fill in.

If no file path is provided, defaults to 'openapi.yaml' in the current directory.

Exit Codes:
  0    All components generated successfully
  2    Error (file not found, validation failed, generation failed, etc.)`,
```

**Context for Implementation:**
- Existing description at `run_cmd.go:205-217`
- Keep existing structure, add --full flag documentation
- Explain conditional behavior clearly

### Testing Requirements

**File**: Manual testing checklist

**Test Scenarios:**

1. **With duh init template:**
```bash
mkdir test-full-init && cd test-full-init
go mod init github.com/test/example
duh init openapi.yaml
duh generate duh openapi.yaml --full
ls -la  # Should see: client.go, server.go, iterator.go, proto/, daemon.go, service.go, api_test.go, Makefile
grep "map\[string\]" service.go  # Should find in-memory implementation
grep "func TestCreateUser" api_test.go  # Should find full test suite
make test  # Should pass
make build  # Should succeed
```

2. **With custom spec:**
```bash
mkdir test-full-custom && cd test-full-custom
go mod init github.com/test/custom
cat > openapi.yaml <<EOF
openapi: 3.0.3
info:
  title: Custom API
  version: 1.0.0
paths:
  /v1/products.create:
    post:
      operationId: createProduct
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateProductRequest'
      responses:
        '200':
          description: Success
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateProductResponse'
        '400':
          description: Bad request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
components:
  schemas:
    Error:
      type: object
      required: [code, message]
      properties:
        code: {type: integer}
        message: {type: string}
    CreateProductRequest:
      type: object
      properties:
        name: {type: string}
    CreateProductResponse:
      type: object
      properties:
        id: {type: string}
EOF
duh generate duh openapi.yaml --full
grep "TODO" service.go  # Should find TODO comments
grep "TODO" api_test.go  # Should find minimal example with TODOs
go build ./...  # Should compile
```

3. **Without --full flag (regression test):**
```bash
mkdir test-no-full && cd test-no-full
go mod init github.com/test/basic
duh init openapi.yaml
duh generate duh openapi.yaml
ls -la  # Should NOT see: daemon.go, service.go, api_test.go, Makefile
```

### Validation Commands

```bash
go test ./internal/generate/duh -v -run TestFullGenerationCompiles
go test ./internal/generate/duh -v -run TestFullGeneratedTestsPass
go test ./internal/generate/duh -v
go build ./...
```

## Success Criteria

### Functional Requirements
- ✅ `--full` flag added to `duh generate duh` command
- ✅ Flag generates 4 additional files: daemon.go, service.go, api_test.go, Makefile
- ✅ Spec matching detects `duh init` template (all 4 endpoints)
- ✅ Full implementation generated for init template specs
- ✅ Stub implementation generated for custom specs
- ✅ All generated files have correct header with timestamp
- ✅ Generated code compiles successfully
- ✅ Generated tests pass (for init template)
- ✅ Makefile targets work correctly

### Code Quality
- ✅ All tests pass: `go test ./internal/generate/duh -v`
- ✅ No linting errors: `make lint`
- ✅ Follows existing code patterns and conventions
- ✅ CLAUDE.md guidelines followed (functional tests, package naming, etc.)

### Documentation
- ✅ CLI help text updated with --full flag documentation
- ✅ Implementation plan completed and reviewed

## Testing Strategy

### Test Organization

**Location**: `internal/generate/duh/` alongside implementation

**Test Files:**
- `matcher_test.go` - Spec matching logic tests
- `templates_test.go` - Template rendering tests
- `full_integration_test.go` - Integration tests with functional style
- `full_e2e_test.go` - End-to-end compilation and execution tests

**Testing Style:**
- ALL tests MUST be functional (per CLAUDE.md)
- Call `duh.RunCmd()` to test through CLI interface
- Verify exit codes and output
- Check generated file contents with file reads
- Each test function stands on its own

**Example Test Pattern:**
```go
func TestGenerateDuhWithFullFlag(t *testing.T) {
    tempDir := t.TempDir()
    specPath := filepath.Join(tempDir, "openapi.yaml")

    // Create go.mod
    require.NoError(t, os.WriteFile(
        filepath.Join(tempDir, "go.mod"),
        []byte("module github.com/test/example\n\ngo 1.24\n"),
        0644,
    ))

    // Create spec
    require.NoError(t, os.WriteFile(specPath, []byte(initTemplateSpec), 0644))

    var stdout bytes.Buffer
    exitCode := duh.RunCmd(&stdout, []string{"generate", "duh", specPath, "--full"})

    require.Equal(t, 0, exitCode)
    assert.Contains(t, stdout.String(), "Generated 8 file(s)")

    // Verify files exist
    _, err := os.Stat(filepath.Join(tempDir, "daemon.go"))
    require.NoError(t, err)

    _, err = os.Stat(filepath.Join(tempDir, "service.go"))
    require.NoError(t, err)

    // Verify content
    serviceContent, err := os.ReadFile(filepath.Join(tempDir, "service.go"))
    require.NoError(t, err)
    assert.Contains(t, string(serviceContent), "map[string]*pb.UserResponse")
}
```

## References

### Key Files to Reference

**Existing Implementation:**
- `run_cmd.go:202-245` - CLI command definition
- `internal/generate/duh/duh.go` - Main generation orchestration
- `internal/generate/duh/generator.go` - Template rendering
- `internal/generate/duh/parser.go` - Spec parsing
- `internal/generate/duh/config.go` - Configuration logic
- `internal/generate/duh/types.go` - Data structures

**Templates:**
- `internal/generate/duh/templates/server.go.tmpl` - Server template example
- `internal/generate/duh/templates/client.go.tmpl` - Client template example
- `internal/generate/duh/templates/iterator.go.tmpl` - Iterator template example

**Reference Implementations:**
- `/Users/thrawn/Development/duh-poc/daemon.go` - Full daemon implementation
- `/Users/thrawn/Development/duh-poc/service.go` - Full service implementation
- `/Users/thrawn/Development/duh-poc/api_test.go` - Full test suite
- `/Users/thrawn/Development/duh-poc/Makefile` - Makefile targets

**Testing Patterns:**
- `internal/generate/duh/integration_test.go` - Integration test examples
- `internal/generate/duh/server_test.go` - Functional test patterns
- `CLAUDE.md` - Testing guidelines and patterns

### Important Patterns

**Template Conditionals:**
```go
{{if .IsFullTemplate}}
// Full implementation
{{else}}
// Stub implementation
{{end}}
```

**Iteration Over Operations:**
```go
{{range .Operations}}
func (s *Service) {{.MethodName}}(ctx context.Context, req *{{.RequestType}}, resp *{{.ResponseType}}) error
{{end}}
```

**First Operation Access:**
```go
{{$firstOp := index .Operations 0}}
func Test{{$firstOp.MethodName}}(t *testing.T)
```
