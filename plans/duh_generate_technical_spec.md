# Technical Specification: Template-Based DUH-RPC Code Generator

## Review Status
- Review Cycles Completed: 1
- Final Approval: **APPROVED FOR IMPLEMENTATION**
- Outstanding Concerns: None - All blocking issues resolved

---

## 1. Overview

This specification describes the implementation of `duh generate duh`, a template-based code generator that transforms DUH-RPC compliant OpenAPI specifications into production-ready Go client and server code. The generator will parse OpenAPI specs, extract operation metadata, and render Go code using embedded text templates.

**Business Value:** Enables developers to maintain a single source of truth (OpenAPI spec) and automatically generate consistent, type-safe client/server implementations with built-in pagination support, eliminating manual code duplication and reducing errors.

---

## 2. Current State Analysis

### Affected Modules

**duh-poc repository** (example output):
- `client.go` (218 lines) - Generated HTTP client with RPC methods and pagination
- `server.go` (137 lines) - Generated HTTP server with handlers and routing
- `iterator.go` (83 lines) - Generic pagination iterator implementation (conditionally generated)
- `proto/v1/api.proto` - Protobuf definitions (generated by external Convert() function)

**duh-cli repository** (generator):
- `run_cmd.go:135-201` - Command registration (will add `duh` subcommand under `generate`)
- `internal/generate/oapi/` - Existing oapi-codegen integration (coexists with new generator)
- `internal/lint/` - OpenAPI validation (will be called programmatically before generation)

### Current Behavior

The existing `duh generate oapi` command uses oapi-codegen to generate generic OpenAPI client/server code. However, this output lacks DUH-RPC specific patterns:
- No RPC-style path constants (`RPCCreateUser = "/v1/users.create"`)
- No pagination iterators for list operations
- Different code structure and conventions
- Generic OpenAPI patterns vs. opinionated DUH-RPC patterns

The new `duh generate duh` command will coexist with `generate oapi` to provide DUH-RPC specific code generation.

### Technical Debt Identified

1. No automated way to generate DUH-RPC specific code from OpenAPI specs
2. Manual maintenance required when OpenAPI spec changes
3. Example files in duh-poc marked "DO NOT EDIT" but no generator exists
4. Risk of drift between OpenAPI spec and implementation

---

## 3. Architectural Context

### Relevant ADRs

No existing ADRs were found in the duh-cli project. This implementation will establish patterns for future code generators.

### Architectural Principles

Based on codebase analysis:
- **Convention over configuration**: DUH-RPC enforces specific path patterns (`/v{N}/{subject}.{method}`)
- **Template embedding**: Use `//go:embed` for distributing templates with binary
- **Validation before generation**: Always lint OpenAPI spec before generating code
- **Package pattern**: Commands delegate to `internal/<command>/` packages
- **Type-safe configuration**: Use structs for configuration, not maps
- **Fail fast**: Stop on first error, no partial generation

---

## 4. Requirements

### Functional Requirements

**REQ-001: OpenAPI Parsing and Operation Extraction**
- Parse OpenAPI 3.0 specifications using libopenapi library (already in dependencies)
- Extract operations from paths (method, operationId, summary, request/response schemas)
- Extract request/response schema references (only top-level named schemas via `$ref`)
- Ignore inline and nested schemas (not used in DUH-RPC pattern)
- Detect list operations requiring pagination iterators using 3-criteria test:
  1. Operation path or operationId contains "list" (case-insensitive)
  2. Request schema contains "offset" property
  3. Response schema contains at least one array field (use first array field found)
- Generate operation names from path using naming algorithm (see REQ-009)
- **Acceptance Criteria**:
  - Successfully parse valid DUH-RPC OpenAPI spec and extract all operations
  - Only operations meeting all three criteria generate pagination iterators
  - Operation names follow deterministic naming rules

**REQ-002: Validation Integration**
- Call `internal/lint.Validate()` to validate OpenAPI spec before generation
- Fail immediately if spec is not DUH-RPC compliant (exit code 2)
- Display validation errors using `internal/lint.Print()`
- No files should be created if validation fails
- **Acceptance Criteria**:
  - Invalid specs are rejected with clear error messages before any code generation
  - Validation errors match format from `duh lint` command

**REQ-003: Client Code Generation**
- Generate `ClientInterface` with all RPC methods
- Generate `Client` struct implementation with method implementations
- Generate RPC path constants for each operation (e.g., `RPCCreateUser = "/v1/users.create"`)
- Generate pagination iterator methods for list operations (e.g., `ListUsersIter()`)
- Generate operation-specific fetcher structs (e.g., `UserPageFetcher`)
- Generate `NewClient()` constructor with validation
- Generate `WithTLS()` and `WithNoTLS()` helper functions with hard-coded connection pool sizes:
  - MaxConnsPerHost: 2000
  - MaxIdleConns: 2000
  - MaxIdleConnsPerHost: 2000
  - IdleConnTimeout: 60 * clock.Second
- **Acceptance Criteria**:
  - Generated client.go compiles successfully with `go build`
  - All expected methods present in ClientInterface
  - Iterator methods only generated for detected list operations

**REQ-004: Server Code Generation**
- Generate `ServiceInterface` with handler method signatures
- Generate RPC path constants (identical to client constants)
- Generate `Handler` struct with `ServeHTTP` method implementing routing via switch/case
- Generate individual handler methods for each operation (e.g., `handleCreateUser`)
- Generate `NewHandler()` constructor accepting `ServiceInterface` and middleware configuration
- Support middleware via `MiddlewareFunc` type and `HandlerConfig` struct
- **Acceptance Criteria**:
  - Generated server.go compiles successfully with `go build`
  - All operations routable via switch/case on request path
  - Middleware applied in correct order

**REQ-005: Iterator Code Generation (Conditional)**
- **Only generate iterator.go if `HasListOps == true`**
- Generate generic `Page[T]` struct with pagination metadata
- Generate `Iterator[T]` interface
- Generate `PageFetcher[T]` interface
- Generate `GenericIterator[T]` implementation with context cancellation support
- Generate `NewGenericIterator[T]()` constructor
- Code should be reusable across all paginated operations
- **Acceptance Criteria**:
  - iterator.go only generated when at least one list operation exists
  - Generated iterator.go compiles successfully
  - Generic types support all detected list operations

**REQ-006: Protobuf Generation via Interface**
- Accept `ProtoConverter` interface:
  ```go
  type ProtoConverter interface {
      Convert(openapi []byte, packageName string) ([]byte, error)
  }
  ```
- Call `converter.Convert(openapiBytes, protoPackageName)` to generate protobuf
- Proto package name logic:
  - If `--proto-package` flag provided, use that value
  - Otherwise, derive from OpenAPI spec version: extract version from first path (e.g., `/v1/...` → `v1`)
  - Default pattern: `duh.api.{version}` (e.g., `duh.api.v1`)
- Write protobuf output to path specified by `--proto-path` flag (default: `proto/v1/api.proto`)
- Overwrite proto file unconditionally without confirmation
- **Acceptance Criteria**:
  - Protobuf file generated at correct path
  - Proto package declaration matches configuration
  - **NOTE**: Functional tests will NOT pass until ProtoConverter implementation is provided (acknowledged limitation)

**REQ-007: Module Path Detection**
- **REQUIRE** go.mod file exists in current directory
- Fail with clear, actionable error if go.mod missing:
  ```
  Error: go.mod not found in current directory

  The 'duh generate duh' command requires a go.mod file to determine
  the module import path for generated code.

  To initialize a Go module, run:
      go mod init github.com/yourorg/yourproject
  ```
- Read `go.mod` file and extract module path from first line: `module <path>`
- Construct proto import path:
  - If `--proto-import` flag provided, use that value directly
  - Otherwise, construct as: `{modulePath}/{protoPathDir}` (e.g., `github.com/duh-rpc/example.go/proto/v1`)
- Use constructed import path in generated Go code: `pb "github.com/duh-rpc/example.go/proto/v1"`
- **Acceptance Criteria**:
  - Fails gracefully with helpful message if go.mod missing
  - Correct import paths in generated code based on actual go.mod
  - --proto-import flag overrides auto-detection

**REQ-008: Configuration Flags**
- `--package` / `-p`: Package name for generated Go code (default: "api")
  - Must be valid Go identifier
  - Cannot be "main"
  - Used for all generated .go files
- `--output-dir`: Output directory for generated files (default: ".")
  - Must already exist (fail if not found)
  - All files written to this directory
- `--proto-path`: Path to proto file relative to module root (default: "proto/v1/api.proto")
  - Used for both writing proto file and constructing import path
- `--proto-import`: Full proto import path (optional, overrides auto-detection)
  - Example: `github.com/myorg/myproject/proto/v1`
  - When provided, ignores module path auto-detection for proto imports
- `--proto-package`: Proto package name (optional, overrides version-based detection)
  - Example: `duh.myapi.v2`
  - Used in proto file package declaration
- **Acceptance Criteria**:
  - All flags work as documented and override defaults correctly
  - Invalid package names rejected with error
  - Missing output directory causes error

**REQ-009: Operation Name Generation Algorithm**

**Source**: Extract from OpenAPI path pattern `/v{version}/{subject}.{method}`

**Algorithm**:
1. Parse path to extract `{subject}.{method}` portion
2. Split on `.` to get subject and method parts
3. Convert each part independently:
   - Split on `-` or `_` separators
   - Capitalize first letter of each word
   - Join without separators
   - Use standard camel case (Id, Http, Url, not ID, HTTP, URL)
4. Concatenate: `{Subject}{Method}`

**Examples**:
| Path | Subject.Method | Operation Name |
|------|----------------|----------------|
| /v1/users.create | users.create | UsersCreate |
| /v1/users.get | users.get | UsersGet |
| /v1/users.list | users.list | UsersList |
| /v1/user-profiles.get-by-id | user-profiles.get-by-id | UserProfilesGetById |
| /v1/message_queue.send | message_queue.send | MessageQueueSend |

**RPC Constant Names**:
- Prefix operation name with "RPC"
- Examples: `RPCUsersCreate`, `RPCUsersGet`, `RPCUserProfilesGetById`

**Fallback**: If operationId is missing from OpenAPI spec, generate from path using this algorithm

**Acceptance Criteria**:
- All operation names are valid Go identifiers
- Names are deterministic (same input always produces same output)
- No naming collisions between operations

**REQ-010: Generated File Headers and Formatting**
- All generated .go files must include header:
  ```go
  // Code generated by 'duh generate' on 2025-10-25 20:15:32 UTC. DO NOT EDIT.
  ```
- Timestamp format: `YYYY-MM-DD HH:MM:SS UTC` (RFC3339 format in UTC timezone)
- Same timestamp used for all files in a single generation run
- **Do NOT include** `//go:build` directives
- Format all .go files with `go/format.Source()` before writing
- **Acceptance Criteria**:
  - All generated files have correct header with UTC timestamp
  - All generated code passes `go fmt` verification
  - No build tag directives present

**REQ-011: Atomic File Generation**
- Use atomic file generation strategy
- On any error during generation:
  - Stop immediately (fail fast)
  - Do NOT write partial files
  - Clean up any temporary files
  - Return error to user
- Only if ALL files generate successfully:
  - Write all files to output directory
  - Overwrite existing files unconditionally without warning
- **Acceptance Criteria**:
  - Failed generation leaves no partial files
  - Successful generation overwrites all files atomically
  - User can safely re-run command after fixing errors

### Non-Functional Requirements

**Performance:**
- Generation should complete in <5 seconds for specs with <50 operations
- Template parsing should happen once (use cached parsed templates)
- File I/O should be minimized (batch writes when possible)

**Reliability:**
- Generated code MUST compile with `go build` (excluding proto converter dependency)
- Generated code MUST pass `go vet`
- All generated files must be properly formatted with gofmt
- Generation must be deterministic (same input = same output)

**Maintainability:**
- Templates should be easy to read and modify
- Clear separation between parsing logic and template rendering
- Comprehensive test coverage for edge cases
- Well-documented template data model

---

## 5. Technical Approach

### Chosen Solution: Embedded text/template-Based Code Generation

The generator uses Go's `text/template` package with embedded template files to transform OpenAPI specifications into DUH-RPC compliant Go code.

### Architecture Components

**1. Template Files** (`internal/generate/duh/templates/`)
```
templates/
├── client.go.tmpl       # Client interface, implementation, iterators, helpers
├── server.go.tmpl       # Server handlers, routing, middleware
└── iterator.go.tmpl     # Generic pagination support (conditional)
```

Templates embedded using:
```go
//go:embed templates/*.tmpl
var templateFS embed.FS
```

**2. Parser** (`internal/generate/duh/parser.go`)
```go
type Parser struct {
    spec *v3.Document
    config Config
}

func (p *Parser) Parse() (*TemplateData, error)
```

**Responsibilities:**
- Parse OpenAPI spec using libopenapi
- Extract operations from paths
- Detect list operations (3-criteria test)
- Extract request/response types (top-level schemas only)
- Build TemplateData structure
- Generate operation names using naming algorithm

**3. Configuration** (`internal/generate/duh/config.go`)
```go
type Config struct {
    PackageName    string
    OutputDir      string
    ProtoPath      string
    ProtoImport    string  // Optional override
    ProtoPackage   string  // Optional override
}

func LoadConfig(flags map[string]string) (*Config, error)
func (c *Config) DetectModulePath() (string, error)
func (c *Config) ConstructProtoImport(modulePath string) string
```

**Responsibilities:**
- Load and validate configuration from flags
- Read go.mod to extract module path
- Construct proto import path (or use override)
- Derive proto package name (or use override)
- Validate package names and paths
- Provide defaults for all configurable values

**4. Generator** (`internal/generate/duh/generator.go`)
```go
type Generator struct {
    templates *template.Template
    config    Config
    timestamp string
}

func NewGenerator(config Config) (*Generator, error)
func (g *Generator) RenderClient(data *TemplateData) (string, error)
func (g *Generator) RenderServer(data *TemplateData) (string, error)
func (g *Generator) RenderIterator(data *TemplateData) (string, error)
func (g *Generator) FormatCode(code string) (string, error)
```

**Responsibilities:**
- Load and parse embedded templates once
- Render templates with parsed data
- Format output using go/format
- Handle template errors gracefully
- Generate consistent timestamp for all files

**5. ProtoConverter Interface** (`internal/generate/duh/converter.go`)
```go
type ProtoConverter interface {
    Convert(openapi []byte, packageName string) ([]byte, error)
}
```

**Note**: Implementation will be provided later. Functional tests requiring compiled code will not pass until this interface is satisfied.

**6. Main Entry Point** (`internal/generate/duh/duh.go`)
```go
func Run(w io.Writer, filePath string, config Config, converter ProtoConverter) error
```

**Orchestration workflow:**
1. Load and validate OpenAPI spec from file
2. Call `internal/lint.Validate()` (fail fast if invalid)
3. Parse configuration, detect module path from go.mod
4. Parse OpenAPI spec into TemplateData using Parser
5. Call `converter.Convert()` to generate protobuf bytes
6. Render client.go using Generator
7. Render server.go using Generator
8. Render iterator.go using Generator (only if HasListOps == true)
9. Format all generated code with gofmt
10. Write all files atomically (proto + Go files)
11. Print success message

### Template Data Model

```go
type TemplateData struct {
    Package      string              // Package name (e.g., "api")
    ModulePath   string              // Module path from go.mod
    ProtoImport  string              // Full proto import path
    ProtoPackage string              // Proto package name
    Operations   []Operation         // All RPC operations
    ListOps      []ListOperation     // Operations requiring iterators
    HasListOps   bool                // Whether any list operations exist
    Timestamp    string              // Generation timestamp (UTC)
}

type Operation struct {
    MethodName    string  // e.g., "CreateUser"
    Path          string  // e.g., "/v1/users.create"
    ConstName     string  // e.g., "RPCCreateUser"
    Summary       string  // Operation summary from OpenAPI
    RequestType   string  // e.g., "CreateUserRequest"
    ResponseType  string  // e.g., "CreateUserResponse"
}

type ListOperation struct {
    Operation              // Embedded base operation
    IteratorName   string  // e.g., "ListUsersIter"
    FetcherName    string  // e.g., "UserPageFetcher"
    ItemType       string  // e.g., "*pb.UserResponse"
    ResponseField  string  // Array field name (e.g., "Users")
}
```

### Template Helper Functions

Templates will have access to these custom functions:

```go
funcMap := template.FuncMap{
    "title":      strings.Title,           // Capitalize first letter
    "lower":      strings.ToLower,         // Convert to lowercase
    "upper":      strings.ToUpper,         // Convert to uppercase
    "hasPrefix":  strings.HasPrefix,       // Check string prefix
    "hasSuffix":  strings.HasSuffix,       // Check string suffix
    "trimPrefix": strings.TrimPrefix,      // Remove prefix
    "trimSuffix": strings.TrimSuffix,      // Remove suffix
    "join":       strings.Join,            // Join string array
}
```

### Generation Flow

```
1. User runs: duh generate duh openapi.yaml [flags]
2. Load OpenAPI spec from file
3. Validate spec using internal/lint (exit code 2 if invalid)
4. Load config from flags and environment
5. Verify go.mod exists, extract module path (error if missing)
6. Parse OpenAPI spec → TemplateData
7. Call converter.Convert(openapiBytes, protoPackageName) → proto bytes
8. Render client.go.tmpl → client.go (formatted)
9. Render server.go.tmpl → server.go (formatted)
10. If HasListOps: Render iterator.go.tmpl → iterator.go (formatted)
11. Write all files atomically to output directory
12. Success message: "✓ Generated N files in <output-dir>"
```

### Rationale

**Why text/template over string building:**
- Complex files (client.go = 218 lines) are easier to maintain as templates
- Visual structure matches output, easier for contributors to understand
- Can reuse template functions for common patterns
- Standard approach in Go ecosystem (protoc-gen-go, stringer, etc.)
- Easier to make formatting changes without touching code

**Why embed templates:**
- Single binary distribution (no external template files needed)
- Templates versioned with code
- Matches existing pattern in `internal/init` package (init/generator.go:3-6)
- Simplifies deployment and testing

**Why separate parser from generator:**
- Clear separation of concerns (data extraction vs. rendering)
- Parser can be tested independently with OpenAPI fixtures
- Template rendering can be tested with mock TemplateData
- Easier to add new output formats later (e.g., TypeScript client)

**Why stop on first error:**
- Prevents partial/corrupted output
- Easier for users to understand what failed
- Atomic generation guarantees consistency
- Matches existing duh-cli error handling pattern

### ADR Alignment

No existing ADRs to align with. This implementation establishes the following patterns for future code generators:
- Use text/template for complex code generation
- Embed templates with go:embed
- Parse once, render many times
- Atomic file generation (all or nothing)
- Validation before generation

### Component Changes

**New Package:** `internal/generate/duh/`
- `duh.go` - Main entry point and orchestration
- `parser.go` - OpenAPI parsing and data extraction
- `config.go` - Configuration loading and validation
- `generator.go` - Template rendering and code formatting
- `converter.go` - ProtoConverter interface definition
- `naming.go` - Operation name generation algorithm
- `templates/client.go.tmpl` - Client code template
- `templates/server.go.tmpl` - Server code template
- `templates/iterator.go.tmpl` - Iterator code template (conditional)
- `testdata/valid-spec.yaml` - Test fixture
- `testdata/list-spec.yaml` - Test fixture with list operations

**Modified:** `run_cmd.go`
- Add `duhCmd` subcommand under `generateCmd` command group
- Register flags: --package, --output-dir, --proto-path, --proto-import, --proto-package
- Create ProtoConverter implementation (or mock for testing)
- Wire up to `duh.Run()` function

**Coexists with:** `internal/generate/oapi/`
- No changes needed to existing oapi generator
- Both generators available under `duh generate` command

---

## 6. Dependencies and Impacts

### External Dependencies

- `github.com/pb33f/libopenapi` (already in go.mod) - OpenAPI parsing
- `text/template` (stdlib) - Template rendering
- `go/format` (stdlib) - Code formatting
- `embed` (stdlib) - Template embedding
- `time` (stdlib) - Timestamp generation
- ProtoConverter implementation - **To be provided later** (blocking functional tests)

### Internal Dependencies

- `internal/lint` package - Spec validation via `Validate()` and `Print()`
- Requires `go.mod` file in target project directory (enforced)
- Requires valid DUH-RPC compliant OpenAPI spec

### Database Impacts

None - this is a code generation tool, no database interactions.

### Impact on Existing Code

- No changes to existing `generate oapi` functionality
- No breaking changes to any existing commands
- Purely additive feature
- Templates coexist with oapi-codegen approach

---

## 7. Backward Compatibility

### Is this project in production?
- [X] No - duh-cli is a development tool, breaking changes are permitted

### Breaking Changes Allowed
- [X] Yes - This is a new command, no backward compatibility concerns

### Migration Strategy

Not applicable - this is a new feature with no migration needed.

Users currently using `duh generate oapi` can continue using it unchanged. The new `duh generate duh` command is complementary, not a replacement.

---

## 8. Testing Strategy

### Unit Testing Approach

**Naming Algorithm Tests** (`naming_test.go`):
```go
func TestGenerateOperationName(t *testing.T)
func TestGenerateConstName(t *testing.T)
func TestPathParsing(t *testing.T)
```
- Test all examples from REQ-009
- Test edge cases (no separator, multiple separators, special chars)
- Test fallback when operationId missing

**Parser Tests** (`parser_test.go`):
```go
func TestParseOperations(t *testing.T)
func TestDetectListOperations(t *testing.T)
func TestExtractSchemaTypes(t *testing.T)
func TestIgnoreInlineSchemas(t *testing.T)
```
- Parse valid OpenAPI spec with multiple operations
- Detect list operations correctly (3-criteria test)
- Extract operation metadata (path, method, types)
- Handle missing operationId gracefully
- Verify only top-level named schemas used

**Config Tests** (`config_test.go`):
```go
func TestLoadConfig(t *testing.T)
func TestDetectModulePath(t *testing.T)
func TestConstructProtoImport(t *testing.T)
func TestMissingGoMod(t *testing.T)
func TestInvalidPackageName(t *testing.T)
```
- Load configuration with various flag combinations
- Extract module path from go.mod
- Construct proto import path from module + proto path
- Override with --proto-import flag
- Error handling for missing go.mod
- Validate package name restrictions

**Generator Tests** (`generator_test.go`):
```go
func TestRenderClient(t *testing.T)
func TestRenderServer(t *testing.T)
func TestRenderIterator(t *testing.T)
func TestFormatCode(t *testing.T)
func TestTemplateErrors(t *testing.T)
```
- Render each template with mock TemplateData
- Verify output compiles (syntax check)
- Format output with gofmt
- Handle template rendering errors gracefully
- Verify conditional iterator.go generation

**Template Tests** (`templates_test.go`):
```go
func TestClientTemplate(t *testing.T)
func TestServerTemplate(t *testing.T)
func TestIteratorTemplate(t *testing.T)
func TestTimestampInHeaders(t *testing.T)
```
- Each template renders without errors for valid input
- Generated code contains expected methods/types
- Generated code passes go vet
- Headers contain timestamp in correct format

### Integration Testing

**End-to-End Test** (`duh_test.go` in root, package `duh_test`):
```go
func TestGenerateDuhCommand(t *testing.T) {
    // Create temp directory
    tempDir := t.TempDir()

    // Create go.mod file
    createGoMod(t, tempDir, "github.com/test/example")

    // Copy test OpenAPI spec
    copyTestSpec(t, tempDir, "testdata/valid-spec.yaml")

    // Create mock ProtoConverter
    converter := &mockConverter{}

    // Run generation
    var stdout bytes.Buffer
    err := duh.Run(&stdout, "openapi.yaml", config, converter)
    require.NoError(t, err)

    // Verify all files generated
    assert.FileExists(t, filepath.Join(tempDir, "client.go"))
    assert.FileExists(t, filepath.Join(tempDir, "server.go"))
    assert.FileExists(t, filepath.Join(tempDir, "proto/v1/api.proto"))

    // Verify files compile
    cmd := exec.Command("go", "build", ".")
    cmd.Dir = tempDir
    output, err := cmd.CombinedOutput()
    require.NoError(t, err, string(output))

    // Verify expected methods exist
    clientCode := readFile(t, filepath.Join(tempDir, "client.go"))
    assert.Contains(t, clientCode, "type ClientInterface interface")
    assert.Contains(t, clientCode, "func (c *Client) CreateUser")
}
```

**Atomic Generation Test** (`atomic_test.go`):
```go
func TestAtomicGeneration(t *testing.T)
func TestCleanupOnError(t *testing.T)
func TestNoPartialFiles(t *testing.T)
```
- Verify all files written or none written
- Simulate errors at different stages
- Verify cleanup of temporary files
- Test idempotency (running twice produces same output)

**Compilation Smoke Tests** (`compile_test.go`):
```go
func TestGeneratedCodeCompiles(t *testing.T) {
    // For each test OpenAPI spec:
    // 1. Generate code
    // 2. Create temp go module
    // 3. Run go build
    // 4. Verify no compilation errors
}
```

**Note**: Tests requiring ProtoConverter will use mock implementation. Full functional tests with real protobuf generation will not pass until ProtoConverter implementation is provided. This is an **acknowledged limitation**.

### User Acceptance Criteria

**Success Criteria:**
1. Generate code from duh-poc/openapi.yaml ✓
2. Generated code structure matches existing duh-poc files ✓
3. Generated client has all expected methods ✓
4. Generated server has all expected handlers ✓
5. Pagination iterators generated for list operations ✓
6. Proto import paths are correct ✓
7. All generated code compiles with go build ✓ (excluding proto converter dependency)
8. No build tag directives in generated files ✓
9. Timestamp present in all file headers ✓
10. Iterator.go only generated when list operations exist ✓

---

## 9. Implementation Notes

### Estimated Complexity

**High** - This is a substantial feature involving:
- Template design for complex Go files (3 templates, ~400 lines of template code)
- OpenAPI parsing and sophisticated data extraction
- Complex naming algorithm implementation
- Integration with external ProtoConverter interface
- Comprehensive testing requirements (unit + integration + smoke tests)
- Atomic file generation with error recovery

**Implementation Time Estimate:**
- Template creation: 2-3 days
- Parser implementation: 2 days
- Naming algorithm: 1 day
- Configuration and module detection: 1 day
- Generator and formatting: 1 day
- Testing and integration: 2-3 days
- Documentation: 1 day
- **Total: 10-12 days for complete implementation**

### Suggested Implementation Order

**Phase 1: Configuration and Naming (Foundation)**
- Implement config loading and validation
- Implement go.mod parsing and module path detection
- Implement operation naming algorithm (naming.go)
- Unit tests for config and naming
- **Deliverable**: Can parse config and generate operation names

**Phase 2: Parser Implementation (Data Extraction)**
- Implement OpenAPI parsing with libopenapi
- Implement operation extraction from paths
- Implement list operation detection (3-criteria test)
- Implement TemplateData construction
- Unit tests for parser
- **Deliverable**: Can parse OpenAPI spec into TemplateData

**Phase 3: Template Development (Code Generation)**
- Create iterator.go.tmpl (simplest, ~80 lines)
- Create client.go.tmpl (~220 lines)
- Create server.go.tmpl (~140 lines)
- Implement template helper functions
- Template tests for each file
- **Deliverable**: Templates render with test data

**Phase 4: Generator Implementation (Rendering Engine)**
- Implement template loading and parsing (go:embed)
- Implement rendering functions for each template
- Implement gofmt integration
- Implement timestamp generation
- Unit tests for generator
- **Deliverable**: Can render templates and format code

**Phase 5: Integration and Orchestration**
- Implement main duh.Run() function
- Implement ProtoConverter interface
- Implement lint integration
- Implement atomic file writing
- Error handling and cleanup
- **Deliverable**: Full generation pipeline works

**Phase 6: Command Registration and Testing**
- Wire up command in run_cmd.go
- Add all configuration flags
- Create mock ProtoConverter for testing
- End-to-end integration tests
- Compilation smoke tests
- **Deliverable**: Command accessible via CLI

**Phase 7: Documentation and Polish**
- Update README.md with examples
- Add inline code documentation
- Create test fixtures for all scenarios
- Final testing pass
- **Deliverable**: Complete, documented, tested feature

### Template Development Tips

**Keep templates readable:**
- Use `{{- ... -}}` sparingly (only where whitespace matters)
- Comment complex template logic with `{{/* comment */}}`
- Break complex expressions into multiple lines
- Use consistent indentation in templates

**Test templates incrementally:**
- Start with static sections (headers, imports)
- Add dynamic sections one at a time
- Test after each addition
- Use test data with edge cases (0 operations, 1 operation, many operations)

**Handle errors gracefully:**
- All template actions should have safe fallbacks
- Use `if` checks before accessing fields
- Provide clear error messages for template failures

### Error Handling Strategy

**Validation Errors** (exit code 2):
```
Error: OpenAPI validation failed

/v1/api/users
  Path must follow format: /v{version}/{subject}.{method}
  Found: /v1/api/users

Run 'duh lint openapi.yaml' for details
```

**Missing go.mod** (exit code 2):
```
Error: go.mod not found in current directory

The 'duh generate duh' command requires a go.mod file to determine
the module import path for generated code.

To initialize a Go module, run:
    go mod init github.com/yourorg/yourproject
```

**Template Errors** (exit code 2):
```
Error: Failed to render client.go template

template: client.go.tmpl:45:12: executing "client.go.tmpl" at <.InvalidField>:
can't evaluate field InvalidField in type *duh.TemplateData

This is a bug in the template. Please report at:
https://github.com/duh-rpc/duh-cli/issues
```

**File Write Errors** (exit code 2):
```
Error: Failed to write client.go

open /path/to/client.go: permission denied

Ensure you have write permissions to the output directory
```

**ProtoConverter Errors** (exit code 2):
```
Error: Failed to generate protobuf

<error message from converter>

Check your OpenAPI schemas for compatibility with protobuf
```

### Code Style Considerations

**Generated Code Should:**
- Match CLAUDE.md guidelines for duh-poc project
- Use visual tapering for struct fields (where applicable)
- Not include build tags (per user decision)
- Include header comment: `// Code generated by 'duh generate' on <timestamp> UTC. DO NOT EDIT.`
- Be formatted with gofmt automatically
- Use consistent naming (camel case for acronyms: Id, Http, Url)
- Import packages in standard order (stdlib, external, local)

### Rollback Strategy

**Atomic Generation:**
- Use temporary directory for all file generation
- Only move files to target directory on complete success
- On any error:
  - Clean up temporary directory
  - Leave target directory unchanged
  - Return error to user
- User can safely re-run command after fixing errors

**Recovery from Errors:**
1. User sees clear error message identifying the problem
2. User fixes the issue (e.g., updates OpenAPI spec)
3. User re-runs `duh generate duh openapi.yaml`
4. Generation completes successfully or shows new error

### Success Message

After successful generation:
```
✓ Generated 4 files in .
  - client.go
  - server.go
  - iterator.go
  - proto/v1/api.proto
```

Or without list operations:
```
✓ Generated 3 files in .
  - client.go
  - server.go
  - proto/v1/api.proto
```

---

## 10. ADR Recommendation

**Recommendation**: Create ADR documenting code generation approach

**ADR Title**: "ADR-001: Use Embedded text/template for DUH-RPC Code Generation"

**Key Decisions to Document:**
1. **Why text/template over string building**
   - Rationale: Maintainability for complex files
   - Alternative considered: Programmatic string building
   - Trade-off: Runtime template errors vs. compile-time safety

2. **Why embed templates vs. external files**
   - Rationale: Single binary distribution
   - Alternative considered: External template files in ~/.duh/templates/
   - Trade-off: Binary size vs. user customization

3. **Template data model design**
   - Rationale: Structured data with clear types
   - Alternative considered: map[string]interface{}
   - Trade-off: Type safety vs. flexibility

4. **Atomic generation strategy**
   - Rationale: Consistency and error recovery
   - Alternative considered: Incremental file writing
   - Trade-off: Performance vs. reliability

5. **Extension points for future generators**
   - Same pattern for TypeScript client generator
   - Same pattern for Python client generator
   - Shared parser, different templates

This ADR establishes patterns that future code generators in the DUH-RPC ecosystem should follow.

---

## 11. Open Questions

### Resolved Questions

All questions from the review have been answered:

1. ✅ **ProtoConverter injection**: Interface defined, implementation provided by caller
2. ✅ **Template embedding**: Use `//go:embed` like internal/init
3. ✅ **Iterator array field**: Use first array field found
4. ✅ **Proto package naming**: Configurable, defaults to version from path
5. ✅ **File overwrite**: Overwrite all unconditionally
6. ✅ **Type extraction**: Use top-level schemas only, prefix with pb.
7. ✅ **Error handling**: Stop on first error
8. ✅ **Operation naming**: Detailed algorithm specified
9. ✅ **Output directory**: Must exist, error if not
10. ✅ **RPC constant naming**: RPC prefix + operation name
11. ✅ **Success message**: Defined with file list
12. ✅ **Iterator.go conditional**: Only if HasListOps == true
13. ✅ **Template functions**: Standard string helpers defined

### Known Limitations

**ProtoConverter Implementation Pending:**
- The ProtoConverter interface is defined but implementation is not yet available
- This is an **acknowledged limitation**
- Functional tests that require compiled code with proto imports will NOT pass
- Tests will use mock ProtoConverter until real implementation is provided
- This does not block implementation of the code generator itself

**Future Enhancements (Out of Scope):**
- Custom template overrides in user projects
- Configuration file support (duh.yaml)
- Incremental generation (only changed operations)
- Source map generation (template line → output line)
- TypeScript client generator
- Python client generator

---

## 12. Example Generation

To illustrate the complete workflow, here's an example showing input and expected output.

### Example Input: openapi.yaml

```yaml
openapi: 3.0.3
info:
  title: Example API
  version: 1.0.0

paths:
  /v1/users.create:
    post:
      operationId: createUser
      summary: Create a new user
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateUserRequest'
      responses:
        '200':
          description: Success
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateUserResponse'

  /v1/users.list:
    post:
      operationId: listUsers
      summary: List users with pagination
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ListUsersRequest'
      responses:
        '200':
          description: Success
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListUsersResponse'

components:
  schemas:
    CreateUserRequest:
      type: object
      properties:
        name:
          type: string
        email:
          type: string

    CreateUserResponse:
      type: object
      properties:
        userId:
          type: string

    ListUsersRequest:
      type: object
      properties:
        limit:
          type: integer
        offset:    # ← List operation criterion #2
          type: integer

    ListUsersResponse:
      type: object
      properties:
        users:     # ← List operation criterion #3 (array field)
          type: array
          items:
            $ref: '#/components/schemas/UserResponse'
        total:
          type: integer

    UserResponse:
      type: object
      properties:
        userId:
          type: string
        name:
          type: string
```

### Example Command

```bash
cd /path/to/project
duh generate duh openapi.yaml --package api --output-dir .
```

### Expected Output Files

**Generated Files:**
1. `client.go` - Contains ClientInterface, Client implementation, UsersListIter method
2. `server.go` - Contains ServiceInterface, Handler, routing
3. `iterator.go` - Contains generic Page, Iterator, PageFetcher types
4. `proto/v1/api.proto` - Generated via ProtoConverter

**client.go excerpt:**
```go
// Code generated by 'duh generate' on 2025-10-25 20:15:32 UTC. DO NOT EDIT.

package api

const (
    RPCUsersCreate = "/v1/users.create"
    RPCUsersList   = "/v1/users.list"
)

type ClientInterface interface {
    CreateUser(ctx context.Context, req *pb.CreateUserRequest, resp *pb.CreateUserResponse) error
    ListUsers(ctx context.Context, req *pb.ListUsersRequest, resp *pb.ListUsersResponse) error
    Close(ctx context.Context) error
}

// ... Client implementation ...

func (c *Client) UsersListIter(limit int32, sortBy pb.SortBy) Iterator[*pb.UserResponse] {
    // ... iterator implementation using UserPageFetcher ...
}

type UserPageFetcher struct {
    client *Client
    limit  int32
}

func (f *UserPageFetcher) FetchPage(ctx context.Context, pageNum int) (*Page[*pb.UserResponse], error) {
    // ... fetch implementation using ListUsers ...
}
```

### Console Output

```
✓ Generated 4 files in .
  - client.go
  - server.go
  - iterator.go
  - proto/v1/api.proto
```

---

## 13. Summary

This specification provides a complete blueprint for implementing the `duh generate duh` command. All blocking issues have been resolved, and the specification is approved for implementation.

### Key Points

✅ **Approach**: Embedded text/template-based code generation
✅ **Templates**: 3 templates (client, server, iterator), embedded with go:embed
✅ **Parsing**: libopenapi for OpenAPI, custom algorithm for operation names
✅ **Generation**: Atomic (all or nothing), formatted with gofmt
✅ **Dependencies**: ProtoConverter interface (implementation pending - acknowledged limitation)
✅ **Testing**: Comprehensive unit, integration, and smoke tests
✅ **Timeline**: 10-12 days estimated implementation time

### Next Steps

1. **Implementation Team**: Begin Phase 1 (Configuration and Naming)
2. **ProtoConverter Team**: Implement converter interface (can happen in parallel)
3. **Documentation Team**: Prepare ADR-001 draft
4. **Testing Team**: Create test fixtures and OpenAPI examples

---

**Specification Status: APPROVED FOR IMPLEMENTATION**
